(function(){const n=document.createElement("link").relList;if(n&&n.supports&&n.supports("modulepreload"))return;for(const t of document.querySelectorAll('link[rel="modulepreload"]'))s(t);new MutationObserver(t=>{for(const o of t)if(o.type==="childList")for(const l of o.addedNodes)l.tagName==="LINK"&&l.rel==="modulepreload"&&s(l)}).observe(document,{childList:!0,subtree:!0});function r(t){const o={};return t.integrity&&(o.integrity=t.integrity),t.referrerPolicy&&(o.referrerPolicy=t.referrerPolicy),t.crossOrigin==="use-credentials"?o.credentials="include":t.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(t){if(t.ep)return;t.ep=!0;const o=r(t);fetch(t.href,o)}})();class N extends Error{constructor(){super("Additional magic is needed to be able to run this function")}}const $=`
A hook was run, but it didnt have any implementations set up for it.

This error might be caused by manually calling a component function
(or a hook directly) outside of act, or by multiple copies of
Act in a project at once!

The renderer is supposed to set up implementation for each hook before
it runs the component.

Check the location of this error, and which version of act your
renderer uses internaly. You might get this error if those are two
different packages!
`.trim();class H extends Error{constructor(){super($)}}const B=`
Encountered an object that is not any of the expected node types, like
string, number, boolean, array, null, or the result of a call to createElement.

Maybe something was accidentally returned from a Component, or was passed
as a child to an element?
`.trim();class M extends Error{constructor(){super(B)}}const I=()=>{throw new H},C={useState:I,useEffect:I,useContext:I},P=e=>typeof e=="function"?e():e,q=(e,n)=>!e||!n?!0:e.length!==n.length||e.some((r,s)=>r!==n[s]),V=(e,n)=>typeof n=="function"?n(e):n,_=e=>C.useState(e),G=(e,n=[])=>C.useEffect(e,n),W=e=>C.useContext(e),U=e=>{const[n]=_(()=>({current:P(e)}));return n},z=(e,n)=>{const r=U(n),s=U(e);return q(r.current,n)&&(r.current=n,s.current=e()),s.current},F=Symbol("provider-node"),K=e=>{throw new N};let Y=0;const T=()=>Y++;function j(e,n,r){return{id:T(),type:e,props:n||{},children:r||[]}}const S=j,x={string:Symbol("string-node"),number:Symbol("number-node"),boolean:Symbol("boolean-node"),null:Symbol("null-node"),array:Symbol("array-node")},A=e=>{switch(typeof e){case"boolean":return S(x.boolean,{value:e});case"number":return S(x.number,{value:e});case"string":return S(x.string,{value:e});case"object":if(e===null)return S(x.null);if(Array.isArray(e))return S(x.array,{},e);if(e.type)return e;throw new M;case"undefined":throw new Error("Undefined is not a valid act element!");default:throw new M}},J=Object.freeze(Object.defineProperty({__proto__:null,MagicError:N,UnknownElementType:M,UnsetHookImplementation:H,calculateDepsChange:q,calculateValue:P,convertNodeToElement:A,createContext:K,createElement:j,createId:T,h:S,hookImplementation:C,primitiveNodeTypes:x,providerNodeType:F,runUpdater:V,useContext:W,useEffect:G,useMemo:z,useRef:U,useState:_},Symbol.toStringTag,{value:"Module"})),Q=(e,n,r)=>({...e,element:n,children:r,version:T()}),X=(e,n,r)=>{const s={created:[],removed:[],nextToPrev:[]};return s.nextToPrev=n.map((t,o)=>{const l=e.findIndex((f,u)=>r(f,t,u,o));return l===-1&&s.created.push(o),l}),s.removed=e.map((t,o)=>s.nextToPrev.indexOf(o)!==-1?-1:o).filter(t=>t!==-1),s},O=(e,n,r)=>{!Array.isArray(r)&&n.length<=1;const t=(Array.isArray(r)?r:[r]).map(A),o=X(n,t,(a,c,w,p)=>a.element.type===c.type&&w===p),l=t.map((a,c)=>{const w=o.nextToPrev[c],p=w!==-1?n[w]:null,h=p&&p.id||T(),i=p&&p.path||[...e.path,h];return{ref:p||{id:h,path:i},prev:p,next:a,targets:[]}}),f=o.removed.map(a=>{const c=n[a];return{ref:c,prev:c,next:null,targets:[]}}),u=[...l,...f];return[l.map(a=>a.ref),u]},Z=(e,n)=>({applyUpdate:(s,{next:t,prev:o,ref:l,targets:f})=>{const u=t&&o&&t.id===o.element.id,d=!!f.find(c=>c.path.includes(l.id));if(u&&!d)return;const a=o&&o.children.map(c=>n.get(c.id))||[];if(t){const c=e.calculateCommitChildren(s,t,l),[w,p]=O(l,a,c),h=Q(l,t,w);s.completedDeltas.push({ref:l,prev:o,next:h}),s.pendingUpdates.push(...p);return}else if(o&&!t){const[,c]=O(l,a,[]);e.clearCommitState(s,l),s.completedDeltas.push({ref:o,prev:o,next:null}),s.pendingUpdates.push(...c);return}else throw new Error("No prev, no next, did this commit ever exist?")}}),ee=(e,n)=>{const r=new Map,s=f=>{const u={ref:f,values:new Map,effects:new Map,deps:new Map};return r.set(f.id,u),u},t=(f,u)=>{const a=(()=>{const c=r.get(u.id)||s(u);let w=0;return{useContext(p){throw new N},useState(p){const h=w++;return c.values.has(h)||c.values.set(h,P(p)),[c.values.get(h),b=>{const m=c.values.get(h),y=V(m,b);c.values.set(h,y),n(u)}]},useEffect(p,h=null){const i=w++;c.effects.has(i)||c.effects.set(i,T());const g=c.deps.get(i)||null,b=c.effects.get(i);c.deps.set(i,h),q(g,h)&&e.enqueueEffect(f,b,p)}}})();C.useContext=a.useContext,C.useState=a.useState,C.useEffect=a.useEffect};return{calculateCommitChildren:(f,u,d)=>{const a=typeof u.type=="function"&&u.type;if(!a)return u.children;const c=u.children,w={...u.props,children:c};return t(f,d),a(w)},clearCommitState:(f,u)=>{const d=r.get(u.id);if(!d)return;const a=[...d.effects.values()];for(const c of a)e.enqueueTeardown(f,c)}}},te=(e,n,r,s,t=o=>{})=>{const o=d=>{const a=d.pendingUpdates.pop();a&&e.applyUpdate(d,a)},l=d=>{for(;d.pendingUpdates.length>0;)o(d)},f=d=>{for(const a of d.completedDeltas)a.next?n.set(a.ref.id,a.next):n.delete(a.ref.id);t(d)};return{runThread:o,syncThread:l,applyThread:f,requestRender:d=>{const a=n.get(r.path[0])||null,c={root:r,pendingEffects:[],pendingUpdates:[{ref:r,prev:a,next:s,targets:[d]}],completedDeltas:[]};l(c),f(c)}}},ne=()=>{const e=new Map;return{enqueueEffect:(s,t,o)=>{s.pendingEffects.push({id:t,task(){const l=e.get(t);l&&(e.delete(t),l()),e.set(t,o())}})},enqueueTeardown:(s,t)=>{s.pendingEffects.push({id:t,task(){const o=e.get(t);o&&(e.delete(t),o())}})}}},L=Symbol("div"),oe=(e,n)=>{const r=new Map,s=new Map,t=new Map,o=T(),l={id:o,path:[o]},f=i=>{switch(typeof i.type){case"function":return null}switch(i.type){case L:return document.createElement("div");case x.string:return document.createTextNode(i.props.value);default:throw new Error(`Unsupported element ${i.type.toString()}`)}},u=(i,g)=>{i instanceof Text&&i.textContent!==g.props.value&&(i.textContent=g.props.value)},d=i=>i.flatMap(g=>{const b=s.get(g.id);if(b)return[b];const m=r.get(g.id);return m?d(m.children):[]}),a=(i,g)=>{const b=d(g);for(let m=0;m<b.length;m++){const y=b[m],E=i.childNodes[m];y!==E&&i.appendChild(y)}},c=ne(),w=ee(c,i=>{h.requestRender(i)}),p=Z(w,r),h=te(p,r,l,A(n),i=>{const g=new Set;for(const{prev:m,next:y,ref:E}of i.completedDeltas){const v=s.get(E.id)||y&&f(y.element);if(!m&&y&&v)g.add([v,y]),s.set(E.id,v),t.set(v,E),E.id===o&&a(e,[y]);else if(m&&!y){if(v&&v.parentNode){const D=t.get(v.parentNode),R=D&&r.get(D.id);R&&g.add([v.parentNode,R]),v.parentNode.removeChild(v),s.delete(E.id),t.delete(v)}}else m&&y&&v&&u(v,y.element)}for(const[m,y]of g)a(m,y.children);const b=r.get(i.root.id);b&&a(e,[b]);for(const m of i.pendingEffects)m.task()});console.log("lol"),h.requestRender(l)},{h:k,useState:re,useEffect:se}=J,ce=()=>{const[e,n]=re(0),r=["Hello","Welcome","Hiya","Hey-ho"];return se(()=>{const s=setInterval(()=>{n(t=>t+1)},1e3);return()=>{clearInterval(s)}},[]),r[e%r.length]},ae=()=>k(L,{style:""},[k(ce)," ","from web!"]);console.log("APP");oe(document.body,k(ae));
